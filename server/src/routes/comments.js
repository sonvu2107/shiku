import express from "express";
import Comment from "../models/Comment.js";
import Post from "../models/Post.js";
import Group from "../models/Group.js";
import User from "../models/User.js";
import { authRequired, authOptional } from "../middleware/auth.js";
import { checkBanStatus } from "../middleware/banCheck.js";
import NotificationService from "../services/NotificationService.js";
import { uploadMultiple, uploadMultipleOptional, uploadToCloudinary, validateFile } from "../middleware/fileUpload.js";
import multer from "multer";

const router = express.Router();

// Test route ƒë·ªÉ ki·ªÉm tra server
router.get("/test", (req, res) => {
  res.json({ message: "Comments API is working", timestamp: new Date().toISOString() });
});

// Test route ƒë·ªÉ ki·ªÉm tra POST kh√¥ng c·∫ßn auth
router.post("/test-post", (req, res) => {
  res.json({ 
    message: "POST test successful", 
    body: req.body,
    files: req.files || [],
    timestamp: new Date().toISOString() 
  });
});

// Middleware ƒë·ªÉ x·ª≠ l√Ω c·∫£ JSON v√† FormData cho comment
const handleCommentUpload = (req, res, next) => {
  const contentType = req.get('Content-Type');
  
  if (contentType && contentType.includes('multipart/form-data')) {
    // FormData - s·ª≠ d·ª•ng multer
    multer({
      storage: multer.memoryStorage(),
      limits: {
        fileSize: 5 * 1024 * 1024, // 5MB per file
        files: 5 // max 5 files
      },
      fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
          cb(null, true);
        } else {
          cb(new Error('Ch·ªâ ch·∫•p nh·∫≠n file h√¨nh ·∫£nh'), false);
        }
      }
    }).array('files', 5)(req, res, (err) => {
      if (err) {
        console.error('Multer error:', err);
        return res.status(400).json({ error: err.message });
      }
      
      // Validate files n·∫øu c√≥ (async)
      if (req.files && req.files.length > 0) {
        validateFiles(req, res, next);
      } else {
        next();
      }
    });
  } else {
    // JSON - kh√¥ng c·∫ßn multer
    req.files = [];
    next();
  }
};

// Helper function ƒë·ªÉ validate files
async function validateFiles(req, res, next) {
  try {
    const validationResults = await Promise.all(
      req.files.map(file => validateFile(file, 'image'))
    );
    
    const invalidFiles = validationResults.filter(result => !result.isValid);
    if (invalidFiles.length > 0) {
      const allErrors = invalidFiles.flatMap(result => result.errors);
      return res.status(400).json({
        error: 'M·ªôt s·ªë file kh√¥ng h·ª£p l·ªá',
        details: allErrors
      });
    }
    
    next();
  } catch (validationError) {
    console.error('File validation error:', validationError);
    return res.status(400).json({ error: 'L·ªói khi validate file' });
  }
}

/**
 * GET /post/:postId - L·∫•y danh s√°ch comment cho 1 b√†i post
 * L·ªçc comment d·ª±a tr√™n blocked users n·∫øu user ƒë√£ ƒëƒÉng nh·∫≠p
 * @param {string} req.params.postId - ID c·ªßa b√†i post
 * @returns {Array} Danh s√°ch comments ƒë√£ l·ªçc
 */
router.get("/post/:postId", authOptional, async (req, res, next) => {
  try {
    let items = await Comment.find({ post: req.params.postId })
      .populate("author", "name avatarUrl role blockedUsers")
      .populate("parent")
      .populate("likes", "name")
      .populate("emotes.user", "name avatarUrl")
      .sort({ createdAt: -1 });

    // üîí L·ªçc comment n·∫øu user ƒë√£ ƒëƒÉng nh·∫≠p
    if (req.user) {
      const currentUser = await User.findById(req.user._id).select("blockedUsers");

      items = items.filter(c => {
        if (!c.author) return false; // b·ªè comment kh√¥ng c√≥ t√°c gi·∫£
        const authorId = c.author._id.toString();

        // m√¨nh block h·ªç
        const iBlockedThem = (currentUser.blockedUsers || [])
          .map(id => id.toString())
          .includes(authorId);

        // h·ªç block m√¨nh
        const theyBlockedMe = (c.author.blockedUsers || [])
          .map(id => id.toString())
          .includes(req.user._id.toString());

        return !iBlockedThem && !theyBlockedMe;
      });
    }

    res.json({ items });
  } catch (e) {
    next(e);
  }
});

/**
 * POST /post/:postId - Th√™m comment (c√≥ th·ªÉ l√† tr·∫£ l·ªùi b√¨nh lu·∫≠n kh√°c)
 * T·∫°o comment m·ªõi ho·∫∑c reply cho comment kh√°c
 * @param {string} req.params.postId - ID c·ªßa b√†i post
 * @param {string} req.body.content - N·ªôi dung comment
 * @param {string} req.body.parentId - ID comment cha (n·∫øu l√† reply)
 * @param {Array} req.files - Danh s√°ch ·∫£nh upload (optional)
 * @returns {Object} Comment ƒë√£ t·∫°o
 */
router.post("/post/:postId", authRequired, checkBanStatus, handleCommentUpload, async (req, res, next) => {
  try {
    const { content, parentId } = req.body;
    const hasImages = req.files && req.files.length > 0;
    if (!content && !hasImages) {
      return res.status(400).json({ error: "Vui l√≤ng nh·∫≠p n·ªôi dung b√¨nh lu·∫≠n ho·∫∑c ƒë√≠nh k√®m ·∫£nh" });
    }

    const post = await Post.findById(req.params.postId).populate("author", "name");
    if (!post) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt" });

    // ===== Group comment permission enforcement (strict) =====
    if (post.group) {
      const group = await Group.findById(post.group);
      if (!group) {
        return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y nh√≥m c·ªßa b√†i vi·∫øt" });
      }

      const userId = req.user._id;
      const isOwner = group.owner.toString() === userId.toString();
      const isAdmin = isOwner || group.isAdmin(userId);
      const isMember = group.isMember(userId);

      const setting = group.settings?.commentPermissions || 'all_members';
      let allowed = false;
      if (setting === 'admins_only') {
        allowed = isAdmin;
      } else if (setting === 'members_only') {
        allowed = isMember || isAdmin;
      } else { // all_members
        allowed = isMember || isAdmin;
      }

      if (!allowed) {
        return res.status(403).json({ error: "Ch·ªâ qu·∫£n tr·ªã vi√™n ƒë∆∞·ª£c ph√©p b√¨nh lu·∫≠n trong nh√≥m n√†y" });
      }
    }

    let parent = null;
    if (parentId) {
      parent = await Comment.findById(parentId).populate("author", "name");
      if (!parent) return res.status(400).json({ error: "Kh√¥ng t√¨m th·∫•y b√¨nh lu·∫≠n g·ªëc" });
    }

    // Upload ·∫£nh l√™n Cloudinary n·∫øu c√≥
    let images = [];
    if (hasImages) {
      try {
        const uploadPromises = req.files.map(file => 
          uploadToCloudinary(file, 'blog/comments', 'image')
        );
        const uploadResults = await Promise.all(uploadPromises);
        console.log("[DEBUG] uploadResults:", uploadResults);
        // Ch·ªâ nh·∫≠n c√°c ·∫£nh c√≥ ƒë·ªß url v√† publicId
        images = uploadResults
          .filter(result => result.url && result.public_id)
          .map(result => ({
            url: result.url,
            publicId: result.public_id,
            width: result.width,
            height: result.height,
            alt: ""
          }));
        if (images.length !== uploadResults.length) {
          console.error("[DEBUG] M·ªôt ho·∫∑c nhi·ªÅu ·∫£nh upload b·ªã thi·∫øu url ho·∫∑c publicId", uploadResults);
          return res.status(400).json({ error: "M·ªôt ho·∫∑c nhi·ªÅu ·∫£nh upload b·ªã thi·∫øu url ho·∫∑c publicId", uploadResults });
        }
      } catch (uploadError) {
        console.error("Error uploading images:", uploadError);
        return res.status(500).json({ error: "L·ªói khi upload ·∫£nh" });
      }
    }

    const commentData = {
      post: post._id,
      author: req.user._id,
      content: content || "",
      parent: parentId || null
    };
    
    // Ch·ªâ th√™m images n·∫øu c√≥
    if (images.length > 0) {
      commentData.images = images;
    }

    const c = await Comment.create(commentData);

    await c.populate([
      { path: "author", select: "name avatarUrl role" },
      { path: "parent" },
    ]);

    // üì¢ G·ª≠i th√¥ng b√°o
    try {
      if (parent) {
        await NotificationService.createReplyNotification(c, parent, post, req.user);
      } else {
        await NotificationService.createCommentNotification(c, post, req.user);
      }
    } catch (notifError) {
      console.error("Error creating notification:", notifError);
    }

    res.json({ comment: c });
  } catch (e) {
    next(e);
  }
});

/**
 * PUT /:id - C·∫≠p nh·∫≠t comment (ch·ªâ ng∆∞·ªùi vi·∫øt)
 * Ch·ªâ cho ph√©p t√°c gi·∫£ comment s·ª≠a n·ªôi dung v√† ·∫£nh
 * @param {string} req.params.id - ID c·ªßa comment
 * @param {string} req.body.content - N·ªôi dung comment m·ªõi
 * @param {Array} req.files - Danh s√°ch ·∫£nh m·ªõi (optional)
 * @returns {Object} Comment ƒë√£ c·∫≠p nh·∫≠t
 */
router.put("/:id", authRequired, handleCommentUpload, async (req, res, next) => {
  try {
    const { content } = req.body;
    const hasImages = req.files && req.files.length > 0;
    if (!content && !hasImages) {
      return res.status(400).json({ error: "Vui l√≤ng nh·∫≠p n·ªôi dung b√¨nh lu·∫≠n ho·∫∑c ƒë√≠nh k√®m ·∫£nh" });
    }

    const c = await Comment.findById(req.params.id);
    if (!c) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y b√¨nh lu·∫≠n" });

    const isOwner = c.author.toString() === req.user._id.toString();
    if (!isOwner) return res.status(403).json({ error: "B·∫°n ch·ªâ c√≥ th·ªÉ s·ª≠a b√¨nh lu·∫≠n c·ªßa m√¨nh" });

    // Upload ·∫£nh m·ªõi l√™n Cloudinary n·∫øu c√≥
    if (hasImages) {
      try {
        const uploadPromises = req.files.map(file => 
          uploadToCloudinary(file, 'blog/comments', 'image')
        );
        const uploadResults = await Promise.all(uploadPromises);
        
        const newImages = uploadResults.map(result => ({
          url: result.url,
          publicId: result.public_id,
          width: result.width,
          height: result.height,
          alt: ""
        }));

        // Thay th·∫ø ·∫£nh c≈© b·∫±ng ·∫£nh m·ªõi
        c.images = newImages;
      } catch (uploadError) {
        console.error("Error uploading images:", uploadError);
        return res.status(500).json({ error: "L·ªói khi upload ·∫£nh" });
      }
    }

    c.content = content || "";
    c.edited = true;
    await c.save();

    await c.populate([
      { path: "author", select: "name avatarUrl role" },
      { path: "parent" },
    ]);

    res.json({ comment: c });
  } catch (e) {
    next(e);
  }
});

/**
 * DELETE /:id - X√≥a comment (ng∆∞·ªùi vi·∫øt, ch·ªß post ho·∫∑c admin)
 * Cho ph√©p t√°c gi·∫£, ch·ªß post ho·∫∑c admin x√≥a comment
 * @param {string} req.params.id - ID c·ªßa comment
 * @returns {Object} Th√¥ng b√°o x√≥a th√†nh c√¥ng
 */
router.delete("/:id", authRequired, async (req, res, next) => {
  try {
    const c = await Comment.findById(req.params.id);
    if (!c) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y b√¨nh lu·∫≠n" });

    const post = await Post.findById(c.post);
    const isOwner = c.author.toString() === req.user._id.toString();
    const isPostOwner = post && post.author.toString() === req.user._id.toString();

    if (!isOwner && !isPostOwner && req.user.role !== "admin") {
      return res.status(403).json({ error: "B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a b√¨nh lu·∫≠n n√†y" });
    }

    await c.deleteOne();
    res.json({ ok: true });
  } catch (e) {
    next(e);
  }
});

/**
 * POST /:id/like - Like/Unlike comment
 * Toggle like status cho comment
 * @param {string} req.params.id - ID c·ªßa comment
 * @returns {Object} Comment ƒë√£ c·∫≠p nh·∫≠t v·ªõi like status
 */
router.post("/:id/like", authRequired, async (req, res, next) => {
  try {
    const comment = await Comment.findById(req.params.id);
    if (!comment) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y b√¨nh lu·∫≠n" });

    const userId = req.user._id;
    const isLiked = comment.likes.includes(userId);

    if (isLiked) {
      // Unlike - x√≥a user kh·ªèi danh s√°ch likes
      comment.likes = comment.likes.filter(id => !id.equals(userId));
    } else {
      // Like - th√™m user v√†o danh s√°ch likes
      comment.likes.push(userId);
    }

    await comment.save();

    // Populate ƒë·ªÉ tr·∫£ v·ªÅ th√¥ng tin ƒë·∫ßy ƒë·ªß
    await comment.populate([
      { path: "author", select: "name avatarUrl role" },
      { path: "parent" },
      { path: "likes", select: "name" }
    ]);

    res.json({ 
      comment,
      isLiked: !isLiked,
      likeCount: comment.likeCount
    });
  } catch (e) {
    next(e);
  }
});

/**
 * POST /:id/emote - Th√™m/x√≥a emote cho comment
 * Toggle emote status cho comment
 * @param {string} req.params.id - ID c·ªßa comment
 * @param {string} req.body.type - Lo·∫°i emote (like, love, laugh, angry, etc.)
 * @returns {Object} Comment ƒë√£ c·∫≠p nh·∫≠t v·ªõi emote status
 */
router.post("/:id/emote", authRequired, async (req, res, next) => {
  try {
    const { type } = req.body;
    if (!type) return res.status(400).json({ error: "Thi·∫øu lo·∫°i emote" });

    const comment = await Comment.findById(req.params.id);
    if (!comment) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y b√¨nh lu·∫≠n" });

    const userId = req.user._id;
    
    // X√≥a t·∫•t c·∫£ emote c≈© c·ªßa user (ƒë·∫£m b·∫£o ch·ªâ c√≥ 1 emote/user)
    comment.emotes = comment.emotes.filter(emote => !emote.user.equals(userId));
    
    // T√¨m emote hi·ªán t·∫°i c·ªßa user v·ªõi type n√†y
    const existingEmoteIndex = comment.emotes.findIndex(
      emote => emote.user.equals(userId) && emote.type === type
    );

    if (existingEmoteIndex >= 0) {
      // N·∫øu ƒë√£ c√≥ emote n√†y r·ªìi th√¨ x√≥a (toggle off)
      comment.emotes.splice(existingEmoteIndex, 1);
    } else {
      // Th√™m emote m·ªõi (ƒë·∫£m b·∫£o ch·ªâ c√≥ 1 emote/user)
      comment.emotes.push({
        user: userId,
        type: type,
        createdAt: new Date()
      });
    }

    await comment.save();

    // Populate ƒë·ªÉ tr·∫£ v·ªÅ th√¥ng tin ƒë·∫ßy ƒë·ªß
    await comment.populate([
      { path: "author", select: "name avatarUrl role" },
      { path: "parent" },
      { path: "emotes.user", select: "name" }
    ]);

    res.json({ 
      comment,
      emoteCount: comment.emoteCount
    });
  } catch (e) {
    next(e);
  }
});

/**
 * GET /:id/emotes - L·∫•y danh s√°ch emotes c·ªßa comment
 * @param {string} req.params.id - ID c·ªßa comment
 * @returns {Object} Danh s√°ch emotes v·ªõi th·ªëng k√™
 */
router.get("/:id/emotes", authRequired, async (req, res, next) => {
  try {
    const comment = await Comment.findById(req.params.id)
      .populate("emotes.user", "name avatarUrl")
      .select("emotes");

    if (!comment) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y b√¨nh lu·∫≠n" });

    // Nh√≥m emotes theo type
    const emoteStats = {};
    comment.emotes.forEach(emote => {
      if (!emoteStats[emote.type]) {
        emoteStats[emote.type] = {
          count: 0,
          users: []
        };
      }
      emoteStats[emote.type].count++;
      emoteStats[emote.type].users.push(emote.user);
    });

    res.json({ 
      emotes: comment.emotes,
      stats: emoteStats
    });
  } catch (e) {
    next(e);
  }
});

export default router;
